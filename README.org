-*- mode:org ; mode:visual-line -*-

Although I don't usually try to pick "fancy" names for packages, Racket already has too many things with "trace" in the name (~racket/trace~, ~calltrace~, ~errortrace~, and more?). As a result I'm calling this Vestige because that is roughly a synonym for trace.

The main, simple ideas here:

- Tracing is useful in at least a couple ways:

  - A debugging technique that is slightly more sophisticated than printf but not as slow and "heavy" as an interactive step debugger.

  - Servers often want to log calls to certain functions -- but doing so manually litters code with cross-cutting concerns.

- ~racket/trace~ does many things right:

  - You can ~trace~ and ~untrace~ functions in the REPL.

  - You can use forms like ~trace-define~ as drop-in replacements. You can do this individually modifying definitions, or wholesale for a module using e.g. ~(require (only-in racket/trace [trace-define define]))~. The latter is a nice way to minimize cross-cutting concerns.

- At the same time, ~racket/trace~ doesn't get some things right:

  - A tool or human would really like to see, not just the name of the function, but also its source location --- enabling quick jumps from an IDE or logfiles to code.

  - It misses the obvious ~trace-expression~ definition in terms of ~trace-let~ to trace individual expressions.

  - The ~current-trace-notify~ parameter assumes strings. Whereas if you supply custom args and results handlers, you might want to supply values like hash-tables or jsexprs. (The latter e.g. for shipping to a "cloud" log service, which includes the ability to query JSON logs.)

I started to prepare a PR for ~racket/trace~. However:

  - It wouldn't be available for people using older versions of Racket.

  - It was awkward to juggle the old/classic approach with the desired new approach.
